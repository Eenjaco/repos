#!/usr/bin/env bash
# mdcon - Universal file to Markdown converter
# Handles: PDF (scanned/text), EPUB, DOCX, HTML â†’ Markdown
#
# Usage: Just run 'mdcon' and follow the prompts

set -eo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Global conversion log
CONVERSION_LOG=""

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_success() {
    echo -e "${CYAN}[SUCCESS]${NC} $1"
}

# Log to conversion log
log_to_file() {
    CONVERSION_LOG="${CONVERSION_LOG}$1"$'\n'
}

# Check dependencies
check_dependencies() {
    local missing=()

    for cmd in pandoc; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done

    # OCR tools are optional (only for scanned PDFs)
    if ! command -v gs &> /dev/null || ! command -v tesseract &> /dev/null; then
        log_warn "OCR tools not installed (gs/tesseract) - scanned PDFs won't work"
        log_warn "Install with: brew install ghostscript tesseract"
    fi

    if [ ${#missing[@]} -ne 0 ]; then
        log_error "Missing required tools: ${missing[*]}"
        echo "Install with: brew install pandoc"
        exit 1
    fi
}

# Detect if PDF is scanned or text-based
is_scanned_pdf() {
    local pdf="$1"

    # Check if pdftotext is available
    if ! command -v pdftotext &> /dev/null; then
        # Assume scanned if we can't check
        return 0
    fi

    # Extract text from first page
    local text
    text=$(pdftotext -l 1 "$pdf" - 2>/dev/null | tr -d '[:space:]')

    # If less than 50 characters, probably scanned
    if [ ${#text} -lt 50 ]; then
        return 0  # Is scanned
    else
        return 1  # Has text
    fi
}

# Convert scanned PDF using OCR
convert_scanned_pdf() {
    local input_pdf="$1"
    local output_md="$2"

    log_info "Detected: Scanned PDF (will use OCR)"

    # Check OCR tools
    if ! command -v gs &> /dev/null || ! command -v tesseract &> /dev/null; then
        log_error "OCR tools not installed. Install with: brew install ghostscript tesseract"
        exit 1
    fi

    # Create temp directory
    local temp_dir
    temp_dir=$(mktemp -d)
    trap "rm -rf '$temp_dir'" EXIT

    log_info "Step 1/4: Extracting pages as images..."
    gs -dNOPAUSE -dBATCH -sDEVICE=png16m \
       -r300 \
       -sOutputFile="$temp_dir/page_%03d.png" \
       "$input_pdf" 2>/dev/null || {
        log_error "Failed to extract PDF pages"
        exit 1
    }

    local page_count
    page_count=$(find "$temp_dir" -name "page_*.png" | wc -l)
    log_info "Extracted $page_count pages"
    log_to_file "PAGES: $page_count (scanned)"

    log_info "Step 2/4: Running OCR on pages..."
    log_to_file "OCR: Processing $page_count pages with Tesseract"
    local ocr_output="$temp_dir/ocr_text.txt"
    > "$ocr_output"

    for page in "$temp_dir"/page_*.png; do
        local page_num
        page_num=$(basename "$page" .png | sed 's/page_//')
        log_info "  OCR page $page_num..."

        tesseract "$page" "$temp_dir/temp_ocr" -l eng --psm 3 2>/dev/null || {
            log_warn "OCR failed for page $page_num, skipping"
            continue
        }

        # Clean up obvious headers/footers/page numbers before adding
        awk -v page="$page_num" '
        BEGIN {
            in_content = 0
            line_count = 0
        }

        # Skip very short lines at start (likely decorative/garbage)
        NR <= 5 && length($0) < 3 { next }

        # Skip standalone numbers (page numbers)
        /^[0-9]+$/ { next }

        # Skip lines with just roman numerals
        /^(i+|iv|v|vi|vii|viii|ix|x|xi|xii|xiii|xiv|xv)$/ { next }

        # Skip lines that are likely headers (ALL CAPS, short)
        /^[A-Z][A-Z ]+$/ && NF <= 6 && NR <= 3 { next }

        # Skip page number patterns like "x2", "12", "Page 5"
        /^[0-9]+$|^[ivxlc]+ *[0-9]*$|^Page [0-9]+$/i { next }

        # Skip very short garbage lines
        length($0) < 2 && NF == 1 { next }

        # Print everything else
        {
            if (!in_content && NF > 3) in_content = 1
            if (in_content || NF > 3) {
                print $0
                line_count++
            }
        }
        ' "$temp_dir/temp_ocr.txt" > "$temp_dir/temp_ocr_clean.txt"

        # Only add page marker if there's actual content
        if [ -s "$temp_dir/temp_ocr_clean.txt" ] && [ $(wc -l < "$temp_dir/temp_ocr_clean.txt") -gt 2 ]; then
            echo "" >> "$ocr_output"
            echo "<!-- Page $page_num -->" >> "$ocr_output"
            echo "" >> "$ocr_output"
            cat "$temp_dir/temp_ocr_clean.txt" >> "$ocr_output"
        fi

        rm -f "$temp_dir/temp_ocr.txt" "$temp_dir/temp_ocr_clean.txt"
    done

    log_info "Step 3/4: Converting to markdown & removing headers/footers..."
    {
        echo "# $(basename "$input_pdf" .pdf)"
        echo ""
        echo "> Converted from scanned PDF on $(date '+%Y-%m-%d')"
        echo ""
        cat "$ocr_output"
    } > "$output_md"

    log_info "Step 4/4: Cleaning up..."
    sed -i.bak '/^$/N;/^\n$/d' "$output_md" && rm -f "${output_md}.bak"
}

# Convert text-based PDF
convert_text_pdf() {
    local input_pdf="$1"
    local output_md="$2"

    log_info "Detected: Text PDF (fast conversion)"

    # Extract text using pdftotext with layout preservation
    local temp_txt temp_clean
    temp_txt=$(mktemp)
    temp_clean=$(mktemp)
    trap "rm -f '$temp_txt' '$temp_clean'" EXIT

    # Use -layout to preserve positioning info
    pdftotext -layout "$input_pdf" "$temp_txt" || {
        log_error "Failed to extract text from PDF"
        exit 1
    }

    # Count PDF pages
    local page_count=$(pdfinfo "$input_pdf" 2>/dev/null | grep "^Pages:" | awk '{print $2}')
    if [[ -n "$page_count" ]]; then
        log_to_file "PAGES: $page_count"
    fi

    # Count extracted lines
    local extracted_lines=$(wc -l < "$temp_txt" | tr -d ' ')
    log_to_file "EXTRACTED: $extracted_lines lines from PDF"

    log_info "Analyzing document for repeated headers/footers..."

    # First pass: Find repeated patterns (likely headers/footers)
    awk '
    BEGIN {
        # Track line frequencies
    }

    # Count non-empty lines
    NF > 0 {
        # Normalize: trim whitespace, lowercase for comparison
        line = tolower($0)
        gsub(/^[ \t]+|[ \t]+$/, "", line)

        # Skip very long lines (unlikely to be headers/footers)
        if (length(line) > 100) next

        # Count occurrences
        if (length(line) > 0) {
            freq[line]++
            original[line] = $0  # Keep original formatting
        }
    }

    END {
        # Lines appearing 3+ times are likely headers/footers
        for (line in freq) {
            if (freq[line] >= 3) {
                print original[line]
            }
        }
    }
    ' "$temp_txt" > "$temp_txt.patterns"

    log_info "Filtering out headers, footers, and page numbers..."

    # Second pass: Remove detected patterns and clean up
    awk -v patterns_file="$temp_txt.patterns" '
    BEGIN {
        # Load patterns to skip
        while ((getline line < patterns_file) > 0) {
            gsub(/^[ \t]+|[ \t]+$/, "", line)
            line_lower = tolower(line)
            skip_patterns[line_lower] = 1
        }
        close(patterns_file)
    }

    {
        # Normalize line for pattern matching (remove all whitespace including form feeds)
        line_lower = tolower($0)
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", line_lower)

        # Skip if matches a repeated pattern
        if (line_lower in skip_patterns) next

        # Skip standalone page numbers (with any amount of whitespace including form feeds)
        if ($0 ~ /^[[:space:]]*[0-9]+[[:space:]]*$/) next

        # Skip lines that are just a number after trimming whitespace
        if (line_lower ~ /^[0-9]+$/) next

        # Skip roman numerals alone (with any whitespace including form feeds)
        if ($0 ~ /^[[:space:]]*(i+|ii|iii|iv|v|vi|vii|viii|ix|x|xi|xii|xiii|xiv|xv)[[:space:]]*$/) next

        # Skip lines with just "Page N" (with any whitespace)
        if ($0 ~ /^[[:space:]]*[Pp][Aa][Gg][Ee] [0-9]+[[:space:]]*$/) next

        # Skip very short lines with just 1-2 characters
        if (length($0) > 0 && length($0) < 3 && NF == 1) next

        # Skip lines that are only whitespace
        if ($0 ~ /^[[:space:]]+$/) next

        # Print everything else
        print $0
    }
    ' "$temp_txt" > "$temp_clean"

    # Create markdown file (skip pandoc for plain text, just use cleaned text directly)
    {
        echo "# $(basename "$input_pdf" .pdf)"
        echo ""
        echo "> Converted from PDF on $(date '+%Y-%m-%d')"
        echo ""
        cat "$temp_clean"
    } > "$output_md"

    # Show what was filtered
    local patterns_count
    patterns_count=$(wc -l < "$temp_txt.patterns" | tr -d ' ')
    if [ "$patterns_count" -gt 0 ]; then
        log_info "Removed $patterns_count repeated header/footer patterns"
        log_to_file "FILTERED: $patterns_count header/footer patterns"
    else
        log_to_file "FILTERED: No repeated patterns detected"
    fi

    # Count final output lines before markdown conversion
    local clean_lines=$(wc -l < "$temp_clean" | tr -d ' ')
    local removed_lines=$((extracted_lines - clean_lines))
    log_to_file "REMOVED: $removed_lines lines (page numbers, whitespace, patterns)"

    rm -f "$temp_txt.patterns"
}

# Convert EPUB
convert_epub() {
    local input_file="$1"
    local output_md="$2"

    log_info "Detected: EPUB file"
    pandoc "$input_file" -f epub -t markdown -o "$output_md" --wrap=none || {
        log_error "Pandoc conversion failed"
        exit 1
    }
}

# Convert DOCX
convert_docx() {
    local input_file="$1"
    local output_md="$2"

    log_info "Detected: DOCX file"
    pandoc "$input_file" -f docx -t markdown -o "$output_md" --wrap=none || {
        log_error "Pandoc conversion failed"
        exit 1
    }
}

# Convert HTML
convert_html() {
    local input_file="$1"
    local output_md="$2"

    log_info "Detected: HTML file"
    pandoc "$input_file" -f html -t markdown -o "$output_md" --wrap=none || {
        log_error "Pandoc conversion failed"
        exit 1
    }
}

# Main conversion router
convert_file() {
    local input_file="$1"
    local output_md="$2"
    local interactive="${3:-true}"  # Default to interactive mode

    # Track conversion time
    local start_time=$(date +%s)

    # Reset conversion log
    CONVERSION_LOG=""

    # Validate input
    if [[ ! -f "$input_file" ]]; then
        log_error "File not found: $input_file"
        exit 1
    fi

    # Log source file
    local file_size=$(ls -lh "$input_file" | awk '{print $5}')
    log_to_file "SOURCE: $(basename "$input_file") ($file_size)"

    # Detect file type and route to appropriate converter
    local extension="${input_file##*.}"
    extension=$(echo "$extension" | tr 'A-Z' 'a-z')  # Convert to lowercase (bash 3.2 compatible)

    log_info "File type: .$extension"
    log_to_file "TYPE: .$extension"

    case "$extension" in
        pdf)
            if is_scanned_pdf "$input_file"; then
                convert_scanned_pdf "$input_file" "$output_md"
            else
                convert_text_pdf "$input_file" "$output_md"
            fi
            ;;
        epub)
            convert_epub "$input_file" "$output_md"
            ;;
        docx)
            convert_docx "$input_file" "$output_md"
            ;;
        html|htm)
            convert_html "$input_file" "$output_md"
            ;;
        *)
            log_error "Unsupported file type: .$extension"
            echo ""
            echo "Supported formats:"
            echo "  - PDF (scanned or text)"
            echo "  - EPUB"
            echo "  - DOCX"
            echo "  - HTML"
            echo ""
            echo "For Google Docs:"
            echo "  1. File â†’ Download â†’ Microsoft Word (.docx)"
            echo "  2. Then convert the .docx file"
            exit 1
            ;;
    esac

    # Calculate conversion time
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Count lines in output
    local line_count=$(wc -l < "$output_md" | tr -d ' ')
    log_to_file "OUTPUT: $line_count lines"
    log_to_file "TIME: ${duration}s"

    # Save conversion log
    local log_file="${output_md%.md}.conversion.log"
    echo "$CONVERSION_LOG" > "$log_file"

    log_info "âœ“ Conversion complete: $output_md"
    log_info "âœ“ Log saved: $log_file"

    # Only show preview and wait in interactive mode
    if [ "$interactive" = "true" ]; then
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "First 15 lines of output:"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        head -n 15 "$output_md"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo -e "${GREEN}âœ“ Done! Press any key to exit...${NC}"
        read -n 1 -s
    fi
}

# Batch convert function
batch_convert() {
    echo -e "${YELLOW}Drag & drop the folder containing documents:${NC}"
    read -r input_folder
    input_folder=$(echo "$input_folder" | xargs)

    if [[ ! -d "$input_folder" ]]; then
        log_error "Folder not found: $input_folder"
        echo "Press any key to exit..."
        read -n 1 -s
        exit 1
    fi

    echo ""
    echo -e "${YELLOW}Output folder (or press Enter for same folder):${NC}"
    read -r output_folder
    output_folder=$(echo "$output_folder" | xargs)

    if [[ -z "$output_folder" ]]; then
        output_folder="$input_folder"
    fi

    if [[ ! -d "$output_folder" ]]; then
        log_error "Output folder not found: $output_folder"
        echo "Press any key to exit..."
        read -n 1 -s
        exit 1
    fi

    echo ""
    log_info "Input folder:  $input_folder"
    log_info "Output folder: $output_folder"
    echo ""

    # Count all supported file types
    local file_count=0
    local temp_list=$(mktemp)

    # Find all supported files
    find "$input_folder" -maxdepth 1 -type f \( \
        -iname "*.pdf" -o \
        -iname "*.epub" -o \
        -iname "*.docx" -o \
        -iname "*.html" -o \
        -iname "*.htm" \
    \) | sort > "$temp_list"

    file_count=$(wc -l < "$temp_list" | tr -d ' ')

    if [ "$file_count" -eq 0 ]; then
        log_error "No supported files found (PDF, EPUB, DOCX, HTML)"
        rm "$temp_list"
        echo "Press any key to exit..."
        read -n 1 -s
        exit 1
    fi

    log_info "Found $file_count files to convert"
    echo ""

    echo -e "${YELLOW}Ready to convert $file_count files?${NC}"
    read -p "Press Enter to continue (or Ctrl+C to cancel)..."
    echo ""

    # Track progress
    local processed=0
    local succeeded=0
    local failed=0
    local skipped=0
    local start_time=$(date +%s)

    # Get existing raw MD count
    local existing_md_count
    existing_md_count=$(find "$output_folder" -maxdepth 1 -type f -name "*-raw.md" 2>/dev/null | wc -l | tr -d ' ')

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "Starting batch conversion..."
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    # Process files
    while IFS= read -r input_file; do
        processed=$((processed + 1))
        local filename=$(basename "$input_file")
        local basename="${filename%.*}"
        local output_file="$output_folder/${basename}-raw.md"

        echo -e "${BLUE}[$processed/$file_count]${NC} $filename"

        # Check if exists
        if [[ -f "$output_file" ]]; then
            echo -e "${YELLOW}  â†’ Already exists, skipping${NC}"
            skipped=$((skipped + 1))
            echo ""
            continue
        fi

        # Convert using non-interactive mode
        if convert_file "$input_file" "$output_file" "false" 2>&1 | grep -q "âœ“"; then
            echo -e "${GREEN}  âœ“ Converted to raw markdown${NC}"
            succeeded=$((succeeded + 1))
        else
            echo -e "${RED}  âœ— Failed${NC}"
            failed=$((failed + 1))
        fi

        echo ""
    done < "$temp_list"

    rm "$temp_list"

    # Get final raw MD count
    local final_md_count
    final_md_count=$(find "$output_folder" -maxdepth 1 -type f -name "*-raw.md" 2>/dev/null | wc -l | tr -d ' ')
    local new_md_count=$((final_md_count - existing_md_count))

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    # Summary
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "Batch Conversion Complete!"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "ğŸ“Š Summary:"
    echo "  Total files:          $file_count"
    echo "  Successfully converted: $succeeded"
    echo "  Failed:               $failed"
    echo "  Skipped (existing):   $skipped"
    echo ""
    echo "ğŸ“ Results:"
    echo "  Raw MD files before: $existing_md_count"
    echo "  Raw MD files after:  $final_md_count"
    echo "  New raw MD files:    $new_md_count"
    echo ""
    echo "ğŸ’¡ Next step: Run 'mdclean' to process raw files into cleaned markdown"
    echo ""
    echo "â±ï¸  Time taken: ${duration}s"
    echo ""
    echo "Output: $output_folder"
    echo ""

    if [ "$failed" -gt 0 ]; then
        log_warn "Some files failed to convert"
    elif [ "$succeeded" -gt 0 ]; then
        log_success "All files converted successfully! ğŸ‰"
    fi

    echo ""
    echo "Press any key to exit..."
    read -n 1 -s
}

# Main interactive script
main() {
    local input_file="$1"
    local output_md="$2"

    # If arguments provided, use non-interactive mode
    if [[ -n "$input_file" ]]; then
        # Non-interactive mode (for batch processing)
        check_dependencies > /dev/null 2>&1

        # Validate input
        if [[ ! -f "$input_file" ]]; then
            log_error "File not found: $input_file"
            exit 1
        fi

        # Default output if not specified - use -raw.md suffix
        if [[ -z "$output_md" ]]; then
            output_md="${input_file%.*}-raw.md"
        else
            # If user specified output, ensure it ends with -raw.md
            if [[ ! "$output_md" =~ -raw\.md$ ]]; then
                output_md="${output_md%-raw.md}-raw.md"
            fi
        fi

        # Run conversion (non-interactive when called with args)
        convert_file "$input_file" "$output_md" "false"
        return
    fi

    # Interactive mode
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘         mdcon - Convert to Markdown            â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "Supports: ${YELLOW}PDF, EPUB, DOCX, HTML${NC} â†’ Markdown"
    echo ""

    # Check dependencies
    check_dependencies
    echo ""

    # Ask mode
    echo -e "${YELLOW}Choose mode:${NC}"
    echo "  1) Convert single file"
    echo "  2) Batch convert folder"
    echo ""
    read -p "Choice [1]: " mode_choice
    mode_choice=${mode_choice:-1}
    echo ""

    if [ "$mode_choice" = "2" ]; then
        # Batch mode
        batch_convert
        return
    fi

    # Single file mode
    echo -e "${YELLOW}Drag & drop your file here (or paste path):${NC}"
    read -r input_file

    # Remove quotes and whitespace
    input_file=$(echo "$input_file" | xargs)

    # Check if file exists
    if [[ ! -f "$input_file" ]]; then
        log_error "File not found: $input_file"
        echo ""
        echo "Press any key to exit..."
        read -n 1 -s
        exit 1
    fi

    log_info "Input: $input_file"
    echo ""

    # Prompt for output location
    echo -e "${YELLOW}Output path (or press Enter for auto: filename-raw.md):${NC}"
    read -r output_md

    # Remove quotes and whitespace
    output_md=$(echo "$output_md" | xargs)

    # Default to same directory as input with -raw.md suffix
    if [[ -z "$output_md" ]]; then
        output_md="${input_file%.*}-raw.md"
    else
        # Ensure -raw.md extension
        if [[ ! "$output_md" =~ -raw\.md$ ]]; then
            output_md="${output_md%-raw.md}-raw.md"
        fi
    fi

    log_info "Output: $output_md"
    echo ""

    # Confirm
    echo -e "${CYAN}Ready to convert:${NC}"
    echo "  From: $input_file"
    echo "  To:   $output_md"
    echo ""
    echo "Press Enter to continue (or Ctrl+C to cancel)..."
    read -r

    # Run conversion
    convert_file "$input_file" "$output_md"
}

# Run
main "$@"
